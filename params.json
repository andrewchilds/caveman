{"name":"Caveman","tagline":"A fast JavaScript template engine","body":"# Caveman\r\n\r\n![Travis](https://travis-ci.org/andrewchilds/caveman.png?branch=master)\r\n\r\nCaveman is a 1KB JS templating engine, written for long-running single-page applications that render thousands or even tens of thousands of DOM elements at a time.\r\n\r\nCaveman's markup language is built on an extensible macro system, which allows for arbitrary script execution, explicit logic, and partials. The library is lightweight, has zero dependencies, and adds a single `Caveman` variable to the global namespace, and seems to be [pretty fast](#benchmarks).\r\n\r\n## Installation\r\n\r\n```sh\r\nnpm install caveman\r\n```\r\n\r\n## Usage\r\n\r\nAssuming a node application with templates in `app/views/templates/*.html` and generated assets in `public/bundled`.\r\n\r\n1. Using Grunt and the [grunt-contrib-caveman](https://github.com/andrewchilds/grunt-contrib-caveman) package, add this to your Gruntfile config:\r\n\r\n    ```js\r\n    caveman: {\r\n      compile: {\r\n        src: ['app/views/templates/*.html'],\r\n        dest: 'public/bundled/templates.js'\r\n      }\r\n    }\r\n    ```\r\n    ```js\r\n    grunt.loadNpmTasks('grunt-contrib-caveman');\r\n    ```\r\n\r\n2. Run Grunt, include `./node_modules/caveman/caveman.js` and the newly created `./public/bundled/templates.js` script tags (in that order) in with your client-side javascripts however you normally would.\r\n\r\n3. You should now have a registry of Caveman templates to use in your client-side code, like so:\r\n\r\n    ```js\r\n    var myTemplateData = { foo: [1, 2, 3], bar: true };\r\n    var html = Caveman.render('myTemplateName', myTemplateData);\r\n    document.getElementById('foo').innerHTML = html;\r\n    ```\r\n\r\n## Concepts\r\n\r\n### Escaping\r\n\r\nCaveman does not escape input by default. It expects you to have already sanitized your data before rendering. If you want to escape HTML in your templates, you can do that with the `escape` macro:\r\n\r\n```html\r\n<div>{{- escape d.html }}</div>\r\n```\r\n\r\n### Scope\r\n\r\nUnlike most template engines, Caveman doesn't use `with` blocks or do any scope lookup. So for top-level variables you'll need to use `{{d.foo}}` instead of `{{foo}}`. Within `for` and `each` blocks, the scope of `d` becomes block-level, as illustrated here.\r\n\r\n```html\r\n<div class=\"posts\">\r\n  {{- for d.posts as post }}\r\n    <h2>{{post.title}}</h2>\r\n    {{- for post.images }}\r\n      <!-- d is now block level. -->\r\n      <img src=\"{{d.src}}\" alt=\"{{d.alt}}\" />\r\n    {{- end }}\r\n    <!-- Scope of d is restored. -->\r\n    {{- for post.images as image }}\r\n      <!-- The scope of d is unaffected since we're using `for as`. -->\r\n      <img src=\"{{image.src}}\" alt=\"{{image.alt}}\" />\r\n      <!-- We can still reference anything further up the scope chain: -->\r\n      {{d.posts[0].images[0].src}}\r\n    {{- end }}\r\n    {{- each post.images[0] }}\r\n      <!-- d is now block-level. -->\r\n      {{_key}}: {{d}}\r\n    {{- end }}\r\n    {{- each post.images[0] as attr }}\r\n      <!-- The scope of d is unaffected since we're using `each as`. -->\r\n      {{_key}}: {{attr}}\r\n      <!-- We can still reference anything further up the scope chain: -->\r\n      {{d.posts[0].images[0].src}}\r\n    {{- end }}\r\n  {{- end }}\r\n</div>\r\n```\r\n\r\n### Custom Macros\r\n\r\nMacros can be easily added or modified. For example, here is a macro that adds zebra stripes and \"first\" and \"last\" classes, depending on where it is in the array:\r\n\r\n```js\r\nCaveman.addMacro('tableClass', {\r\n  find: /^tableClass$/\r\n  replace: \"str += (_i % 2 ? 'even' : 'odd');\" +\r\n    \"if (_i === 0) { str += ' first'; }\" +\r\n    \"if (_i === _len - 1) { str += ' last'; }\";\r\n});\r\n\r\ndata = {\r\n  rows: [\r\n    { text: 'a' }\r\n    { text: 'b' }\r\n    { text: 'c' }\r\n  ]\r\n}\r\n\r\nCaveman(template, data)\r\n```\r\n\r\n```html\r\n<!-- template -->\r\n<table>\r\n  {{- for d.rows as row }}\r\n    <tr class=\"{{- tableClass }}\">\r\n      <td>{{_i}}: {{row.text}}</td>\r\n    </tr>\r\n  {{- end }}\r\n</table>\r\n\r\n<!-- rendered HTML -->\r\n<table>\r\n  <tr class=\"odd first\">\r\n    <td>0: a</td>\r\n  </tr>\r\n  <tr class=\"even\">\r\n    <td>1: b</td>\r\n  </tr>\r\n  <tr class=\"odd last\">\r\n    <td>2: c</td>\r\n  </tr>\r\n</table>\r\n```\r\n\r\n### Arbitrary Script Execution\r\n\r\n```js\r\nCaveman(template, {\r\n  rows: [1, 2, 3]\r\n});\r\n```\r\n\r\n```html\r\n<!-- template -->\r\n{{- for d.rows }}\r\n  <div>{{d}} x {{d}} = {{- print d * d }}</div>\r\n{{- end }}\r\n\r\n<!-- rendered HTML -->\r\n<div>1 x 1 = 1</div>\r\n<div>2 x 2 = 4</div>\r\n<div>3 x 3 = 9</div>\r\n```\r\n\r\n## Interpolation Behavior\r\n\r\n```html\r\n<!-- exampleTemplate.html -->\r\nstring: {{d.strings}}\r\nempty string: {{d.emptyString}}\r\nboolean false: {{d.booleanFalse}}\r\nboolean true: {{d.booleanTrue}}\r\nnull: {{d.nullValue}}\r\nundefined: {{d.undefinedValue}}\r\nfloats: {{d.floats}}\r\nintegers: {{d.ints}}\r\nzero: {{d.zero}}\r\narrays (bracket notation): {{d.arrays[2]}}\r\narrays of objects (dot and bracket notation): {{d.arraysOfObjects[1].b}}\r\n```\r\n\r\n```js\r\nCaveman.render('exampleTemplate', {\r\n  strings: \"123\",\r\n  emptyString: '',\r\n  booleanFalse: false,\r\n  booleanTrue: true,\r\n  nullValue: null,\r\n  undefinedValue: undefined,\r\n  floats: 123.12,\r\n  ints: 1234,\r\n  zero: 0,\r\n  arrays: [1, 2, 3, 4]\r\n  arraysOfObjects: [\r\n    { a: 1, b: 2, c: 3 },\r\n    { a: 1, b: 2, c: 3 }\r\n  ]\r\n});\r\n```\r\n\r\n```html\r\n<!-- rendered HTML -->\r\nstring: 123\r\nempty string:\r\nboolean false: false\r\nboolean true: true\r\nnull:\r\nundefined:\r\nfloats: 123.12\r\nintegers: 1234\r\nzero: 0\r\narrays (bracket notation): 3\r\narrays of objects (dot and bracket notation): 2\r\n```\r\n\r\n## Macro Documentation\r\n\r\n#### {{- if *expression* }}\r\n#### {{- unless *expression* }}\r\n#### {{- else }}\r\n#### {{- else if *expression* }}\r\n#### {{- end }}\r\n\r\n```html\r\n<div class=\"posts\">\r\n  {{- for d.posts as post }}\r\n    {{- unless post.hidden }}\r\n      <h2>{{post.title}}</h2>\r\n      {{- if post.comments.length > 0 }}\r\n        {{- for post.comments as comment }}\r\n          <div class=\"comment\">{{comment.text}}</div>\r\n        {{- end }}\r\n      {{- else }}\r\n        <div>No comments!</div>\r\n      {{- end }}\r\n    {{- end }}\r\n  {{- end }}\r\n</div>\r\n```\r\n\r\nThe `if`, `unless`, and `end` macros have shortcuts, respectively:\r\n\r\n#### {{? *expression* }}\r\n#### {{^ *expression* }}\r\n#### {{/}}\r\n\r\n-----\r\n\r\n#### {{- for *array* }}\r\n#### {{- for *array* as *obj* }}\r\n\r\nThe `for` macro iterates through arrays. These variables are available in the block scope:\r\n\r\n* `_i` = the current index of the for loop, starting with zero\r\n* `_len` = the length of the for loop.\r\n\r\n```js\r\nvar data = {\r\n  users: [\r\n    { name: 'Jimmy', email: 'jimmy@gmail.com' },\r\n    { name: 'Ralph', email: 'ralph@gmail.com' }\r\n  ]\r\n};\r\nCaveman(template, data);\r\n```\r\n\r\n```html\r\n<!-- template -->\r\n<div class=\"users\">\r\n  {{- for d.users as user }}\r\n    <div class=\"user\">\r\n      <label>Name</label> <strong>{{user.name}}</strong>\r\n      <label>Email</label> <a href=\"mailto:{{user.email}}\">{{user.email}}</a>\r\n    </div>\r\n  {{- end }}\r\n</div>\r\n\r\n<!-- rendered HTML -->\r\n<div class=\"users\">\r\n  <div class=\"user\">\r\n    <label>Name</label> <strong>Jimmy</strong>\r\n    <label>Email</label> <a href=\"mailto:jimmy@gmail.com\">jimmy@gmail.com</a>\r\n  </div>\r\n  <div class=\"user\">\r\n    <label>Name</label> <strong>Ralph</strong>\r\n    <label>Email</label> <a href=\"mailto:ralph@gmail.com\">ralph@gmail.com</a>\r\n  </div>\r\n</div>\r\n```\r\n\r\n-----\r\n\r\n#### {{- each *obj* }}\r\n#### {{- each *obj* as *attr* }}\r\n\r\n`each` is meant for iterating through object properties, using a closure instead of a for loop. The `_key` variable is available in the block scope.\r\n\r\n```js\r\ndata = {\r\n  cars: [\r\n    {\r\n      make: 'Volvo',\r\n      model: '245s',\r\n      year: 1976,\r\n    },\r\n    {\r\n      make: 'Saab',\r\n      model: '900s',\r\n      year: 1985\r\n    }\r\n  ]\r\n};\r\n```\r\n```html\r\n<!-- template -->\r\n{{- for d.cars as car }}\r\n  <div class=\"car\">\r\n    {{- each car as attribute }}\r\n      <div>{{_key}}: {{attribute}}</div>\r\n    {{- end }}\r\n  </div>\r\n{{- end }}\r\n\r\n<!-- rendered HTML -->\r\n<div class=\"car\">\r\n  <div>make: Volvo</div>\r\n  <div>model: 245s</div>\r\n  <div>year: 1976</div>\r\n</div>\r\n<div class=\"car\">\r\n  <div>make: Saab</div>\r\n  <div>model: 900s</div>\r\n  <div>year: 1984</div>\r\n</div>\r\n```\r\n\r\n-----\r\n\r\n#### {{- with *a.b.c.obj* }}\r\n#### {{- with *a.b.c.obj* as *obj* }}\r\n\r\n`with` allows you to scope an object to `d` (or to anything, using `with foo as bar`) within a block.\r\n\r\n```html\r\n<!-- template -->\r\n{{- for d.posts as post }}\r\n  {{- with post.author as author }}\r\n    <h2>{{author.name}}</h2>\r\n  {{- end }}\r\n{{- end }}\r\n\r\n<!-- rendered HTML -->\r\n<div>1 x 1 = 1</div>\r\n<div>2 x 2 = 4</div>\r\n<div>3 x 3 = 9</div>\r\n```\r\n\r\n-----\r\n\r\n#### {{- print *expression* }}\r\n\r\n`print` writes the expression's returned value. The `_i` character is the current index of the array. `d` is the current value, which happens to be a string.\r\n\r\n```html\r\n<!-- template -->\r\n{{- for d.rows }}\r\n  <div>{{d}} x {{d}} = {{- print d * d }}</div>\r\n{{- end }}\r\n\r\n<!-- rendered HTML -->\r\n<div>1 x 1 = 1</div>\r\n<div>2 x 2 = 4</div>\r\n<div>3 x 3 = 9</div>\r\n```\r\n\r\n-----\r\n\r\n#### {{- log *expression* }}\r\n\r\nWrites {expression} to console.log.\r\n\r\n```js\r\n{{- log x.y.z }}\r\n```\r\n\r\n-----\r\n\r\n#### {{- render *partialName* }}\r\n#### {{- render *partialName* *context* }}\r\n\r\nRenders partial {name} using optional {scope}.\r\n\r\nCompiled templates should be registered using the `Caveman.register` method so they can be used as partials.\r\n\r\n```js\r\nCaveman.register('emailList', emailList)\r\nCaveman.register('emailLink', emailLink)\r\n\r\nvar data = {\r\n  emails: [\r\n    { email: 'jimmy@gmail.com', name: 'Jimmy' },\r\n    { email: 'ralph@gmail.com', name: 'Ralph', className: 'active' },\r\n    { email: 'joe@gmail.com', name: 'Joe' }\r\n  ]\r\n};\r\nCaveman.render('emailList', data);\r\n```\r\n\r\n```html\r\n<!-- \"emailList\" template -->\r\n{{- for d.emails }}\r\n  <div class=\"user\">{{- render emailLink }}</div>\r\n{{- end }}\r\n\r\n<!-- \"emailLink\" template -->\r\n<a href=\"mailto:{{d.email}}\" class=\"{{d.className}}\">{{d.name}}</a>\r\n\r\n<!-- rendered HTML -->\r\n<div class=\"user\">\r\n  <a href=\"mailto:jimmy@gmail.com\" class=\"\">Jimmy</a>\r\n</div>\r\n<div class=\"user\">\r\n  <a href=\"mailto:ralph@gmail.com\" class=\"active\">Ralph</a>\r\n</div>\r\n<div class=\"user\">\r\n  <a href=\"mailto:joe@gmail.com\" class=\"\">Joe</a>\r\n</div>\r\n```\r\n\r\n## Method Reference\r\n\r\n#### Caveman\r\n\r\nReturns either a compiled template function, or the rendered HTML if data is passed in. The latter approach should not be used in production as the compiled template is not cached.\r\n\r\n```js\r\nCaveman(template) // returns compiled template function\r\nCaveman(template, data) // returns rendered HTML\r\n```\r\n\r\n-----\r\n\r\n#### Caveman.compile(*template*)\r\n\r\nReturns a compiled template string. If you're sending pre-compiled templates to the client, you should use this method, otherwise you don't really need to use this. If you're compiling templates on the client-side, you should just use `Caveman.register` and `Caveman.render`.\r\n\r\n```js\r\nvar template = '{{- for d.users as user }}<span>{{user.name}}</span>{{- end }}'\r\nvar compiled = Caveman.compile(template);\r\n\r\nCaveman.register('userNames', compiled);\r\n```\r\n\r\n-----\r\n\r\n#### Caveman.register(*templateName*, *uncompiledTemplateString*)\r\n#### Caveman.register(*templateName*, *compiledTemplateFunction*)\r\n\r\nRegister a partial {name} using template {template}, allowing it to be used later on with `Caveman.render`. Accepts both compiled and uncompiled templates.\r\n\r\n```js\r\nvar template = '{{- for d.users as user }}<span>{{user.name}}</span>{{- end }}'\r\nCaveman.register('userNames', template);\r\n```\r\n\r\n-----\r\n\r\n#### Caveman.render(*templateName*, *data*)\r\n\r\nRender a compiled template {name} using {data}.\r\n\r\n```js\r\nvar data = {\r\n  users: [ { name: 'Mario' }, { name: 'Luigi' } ]\r\n}\r\nCaveman.render('userNames', data);\r\n// > \"<span>Mario</span><span>Luigi</span>\"\r\n```\r\n\r\n-----\r\n\r\n#### Caveman.addMacro(*macroName*, *macroDefinition*)\r\n\r\nAdds or updates a macro {macroName} with macro {macro}. Macros are objects with the following keys:\r\n\r\n* find: Required. The regex to test the str against.\r\n* replace: Required. A string or function that returns a replacement expression.\r\n* blockEnd: Optional. If this is a block, what should be added during the matching {{- end }} macro.\r\n* prefix: Optional. If anything needs to be added at the beginning of the compiled template.\r\n* shortcut: Optional. Define a shortcut syntax for this macro.\r\n\r\nAll existing macros are defined using this method, for example:\r\n\r\n```js\r\nCaveman.addMacro('if', {\r\n  find: /^if /,\r\n  replace: function (str) {\r\n    return str.replace(/^if (.*)/, 'if ($1) {');\r\n  },\r\n  blockEnd: '}',\r\n  shortcut: {\r\n    find: /^\\?\\s?/,\r\n    replace: function (str) {\r\n      return str.replace(/^\\?\\s?(.*)/, '- if $1');\r\n    }\r\n  }\r\n});\r\n\r\nCaveman.addMacro('print', {\r\n  find: /^print /,\r\n  replace: function (str) {\r\n    return str.replace(/^print (.*)/, 'str += ($1);');\r\n  }\r\n});\r\n```\r\n\r\n-----\r\n\r\n## Caveman.options\r\n\r\nTo use custom tags (e.g. ERB-style tags), override these two options before compiling your templates:\r\n\r\n```js\r\nCaveman.options.openTag = '<%';\r\nCaveman.options.closeTag = '%>';\r\n```\r\n\r\nRemove indentation by shrink wrapping your templates:\r\n\r\n```js\r\nCaveman.options.shrinkWrap = true;\r\n```\r\n\r\n## Benchmarks\r\n\r\nIf you only look at [pure rendering](http://jsperf.com/js-templating-performance/5) performance, Caveman shows a dramatic performance gain over Hogan, Handlebars and Lodash:\r\n\r\n![benchmark-without-dom](http://i.imgur.com/7wKwTwJ.png)\r\n\r\nHowever a more [real-world test](http://jsperf.com/js-templating-performance/4) that includes DOM manipulation shows a more modest improvement:\r\n\r\n![benchmark-with-dom](http://i.imgur.com/28xpRTv.png)\r\n\r\nYMMV.\r\n\r\n## Running the Jasmine tests\r\n\r\n```sh\r\nnpm test\r\n```\r\n\r\n## License\r\n\r\nMIT. Copyright &copy; 2014 Andrew Childs\r\n","google":"UA-2103966-2","note":"Don't delete this file! It's used internally to help with page regeneration."}